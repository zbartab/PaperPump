---
title: Simulations of publication and collaboration networks
author: Z. Barta; T. Magura
date: !__DATE__
---

&define pubnet publication network
&define colnet collaboration network
&define pubcart publication cartel

# Generation of random !pubnet

A !pubnet is represented by a _p_ by _A_ matrix where the value of 1 in
cell (_i_, _j_) marks that author _j_ contributed to a paper _i_. This
representation corresponds to a bipartite network with authors and
papers being the different types of nodes. Links between them shows
authorship relation. To represent a !pubnet we use SparseMatrices.

```julia
using StatsBase, Statistics, PyPlot, Compose, Cairo
using LightGraphs, MetaGraphs, GraphPlot
include("CollaborationNetworks.jl")
```

Next, we set the basic parameters.

```julia
p = 100000
A = 3000
```

We assume a power law distribution of degrees between the nodes. This
basically means that the number of paper an author writes follows a
power law distribution. To generate a given power law distribution we
use the technique outlined in [Barabási's Network Science book (BOX
4.7)](http://networksciencebook.com/chapter/4#generating-networks). We
prepare the function `expectedpapers` for this.

The next step is to write a function which generates the !pubnet. This
is based on the following assumptions. We have `A` authors. The number
of papers an author produces follows a power law distribution, i.e. some
authors with very high number of papers occur with finite probability.
The function requires an array containing the number of papers produced
by each author. We assume that authors produce papers independently to
each other, but this does not exclude the possibility that some papers
produced by more than one author. The procedure is implemented in the
function `generate_publicationmatrix`.

And here is the production of !pubmat. First, we generate a random
distribution of papers written by an author and then generate the matrix
itself.

```julia
k_rand = expectedpapers(A, p, 2.5, 5)
pubmat = generate_publicationmatrix(k_rand, 1.0)
```


&define pubmat publication matrix
&define colmat collaboration matrix

We calculate some properties of the !pubmat. First, a couple of functions to bin
values on linear or log-log scale, following
[Barabási](http://networksciencebook.com/chapter/4#advanced-b).

According to the distribution plots below, the number of papers written by an
author follows a power law distribution, which is not surprising because
we simulated so.

```julia
d = loglogbins(k_rand)
pk = linbins(Int.(k_rand))
close()
PyPlot.grid(true)
scatter(log10.(1:length(pk)), log10.(pk))
title("Number of papers per author")
xlabel(L"$\log_{10}(k)$")
ylabel(L"$\log_{10}(p_k)$")
scatter(log10.(d["kn"]), log10.(d["pk"]))
tight_layout()
```

Next we calculate the number of coauthors in a paper.

```julia
n_papers = size(pubmat, 1)
n_authors = zeros(n_papers)
for i in 1:n_papers
	n_authors[i] = sum(pubmat[i,:])
end
pa = linbins(Int.(n_authors))
close()
scatter(log10.(1:length(pa)), log10.(pa))
title("Number of coauthors per paper")
xlabel(L"$\log_{10}$(number of coauthors)")
ylabel(L"$\log_{10}(p_k)$")
PyPlot.grid(true)
tight_layout()
```



From the !pubmat we create the !colmat. This is a matrix where
the cell _i_,_j_ contains the Jaccard simmilarity between author _i_,
and _j_. Only the upper triangle of the matrix is used.

```julia
colmat = collaborationmatrix(pubmat)
```

From the !colmat we produce the !colnet as an undirected, weighted graph.


```julia
colnet = collaborationgraph(colmat)
Compose.draw(PNG("proba.png", 50cm, 50cm), gplot(colnet,
	layout=random_layout))
```

Some properties of the simulated !colnet.

Degree distribution:

```julia
ds = degree(colnet)
d = loglogbins(ds)
close()
scatter(log10.(d["kn"]), log10.(d["pk"]))
PyPlot.grid(true)
xlabel(L"$\log_{10}(k)$")
ylabel(L"$\log_{10}(p_k)$")
title("degree distribution of collaboration network")
tight_layout()
```

Weigth distribution:

```julia
W = Weights(colnet)
d = loglogbins(100 .* W)
close()
scatter(log10.(d["kn"] ./ 100), log10.(d["pk"]))
PyPlot.grid(true)
xlabel(L"$w$")
ylabel(L"$\log_{10}(p_w)$")
title("weight distribution of collaboration network")
tight_layout()
```

Filtering nodes with high weight edges.

```julia
heavyW = filter_edges(colnet, (g, e) -> LightGraphs.weights(g)[src(e),
											dst(e)] > 0.4)
hw_colnet = colnet[heavyW]
Compose.draw(PNG("hw.png", 50cm, 50cm), gplot(hw_colnet,
	layout=spring_layout))
```

We now describing the cartels in `colnet`.

```julia
describecartels(colnet)
```


# Using the MTMT dataset to estimate simulation parameters

To calibrate our simulations we use the [MTMT](https://mtmt.hu)
[dataset](../publication_patterns.Rmd) which contains publication records for
more than 20,000 authors, mainly based in Hungary. 

After processing the downloaded records, we
[derived](../publication_patterns.Rmd) the number of papers for each
author in the dataset. We load now this data here.

```julia
using CSV
l = CSV.read("../MTMT_no_papers.csv")
ll = l[:,2]
```

The distribution plot of this dataset indicates that we do not have a
pure power law distribution here. The curve resembles to a saturated
power law distribution with a cut off for high degrees. 

```julia
plotloglog(ll)
```

We approximate this distribution with a function given in [Barabási's
book (BOX 4.10)](http://networksciencebook.com/chapter/4#advanced-b).
This is implemented in the function `saturatedexpectedpapers`. After
several trial-and-error runs we arrived to the following parameter
estimates, which seem to describe well the distribution of the real
data:

- `gamma`: 2.5
- `k_sat`: 10
- `k_cut`: 450

```julia
kMTMT = []
for i in 1:10
	push!(kMTMT, saturatedexpectedpapers(23507, 1000000, 2.5, 10, 450))
end
map(plotloglog, kMTMT)
plotloglog(ll)
```

# Simulations

An exemplary simulation.

```julia
rcolnet = rnd_collaborationnetwork(300, scaling=1.5)
addcartel!(rcolnet, collect(1:5))
graphplot(rcolnet, layout=spring_layout)
summarystats(degree(rcolnet))
describecartels(rcolnet)
```


# MTMT dataset

We have to load the records for the authors downloaded from the
[MTMTM](https://mtmt.hu) database. For how the records were downloaded
see the [Rmd file](../publication_patterns.Rmd).

```julia
using CodecZlib, JSON

mtmt_records = readdir("../MTMT-downloads/")
mtmt_records = filter((x) -> occursin(r"[0-9].json$", x), mtmt_records)
mtmt_dir = joinpath(homedir(),
	"Projects/PaperPump/analyse-publications/MTMT-downloads/")

f = mtmt_records[1]

r = JSON.parsefile(joinpath(mtmt_dir, f))

 a =
JSON.parsefile(GzipDecompressorStream(open("/home/apa/Projects/PaperPump/analyse-publications/MTMT-downloads/10000090_2019-11-24.json.gz")))
```

